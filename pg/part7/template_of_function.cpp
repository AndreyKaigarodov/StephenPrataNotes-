#include <iostream>
using namespace std;

//Простой пример
template <typename AnyType>
void swap(AnyType &a, AnyType &b){
    AnyType tmp = a;
    a = b;
    b = tmp;
}

/*
template и typename - обязательны естестно, а вот
template и classs взаимозаменяемы
!Шаблон - не функция, а инструкция для компилятора по определению функции
Когда компилятор встречает вызов функции, для которой есть шаблон, 
она смотрит на тип и создает функцию т.е. дублирует ее (делает перегрузку) для
других типов данных
*/

//Перегрузка шаблонов
template<typename T>
void swap(T a[], T b[], int n);

/*409 стр Существует ряд подходов для функций
- Одно и то же имя применяется для нешаблонной функции, шаблонной функции и явной специализании шаблона (+перегрузки)
- Прототип и определение явной специализации доолжно быть предварено template<> и указывать имя обобщеного типа данных
- Специализация переопределяет обычный шаблон, а нешаблонноя функция переопределяет и спициализацию. и шаблон
Прототипы:
нешаблонная функция - void Swap(job &, job &);
прототип шаблона - template <typename T> void Swap (T &, T &);
явная специализация для типа - template<> void Swap<job>(job &, job &)
явня специализация может содержать строки типа: t1 = j1.name; и т.д. под класс крч, но
зачем в таком случае template<> ?
job - структура простенькая
*/

/*Можно явно сказать компилятору, что нужно создать функцию под данный тип
вот так: template void Swap<int>(int, int) - явное создание экземпляров

question: 412 стр
А еще есть
template <> Swap<int> (int& , int&) - явная специализация
Вроде говорит компилятору: "не применяй шаблон функции Swap() для генерации определения функции, вместо этого
используй отделное определение функции, явно сформулированное для типа int"
и как следует полагать явное создание экземпляра и явная специализация не должны использоваться в одном файле
иначе получаем ошибку
*/
//bookmark: 414
int main(){
    
    return 0;
}